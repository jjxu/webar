<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>WebAR</title>
	<script type="text/javascript" src="./js-aruco/cv.js"></script>
	<script type="text/javascript" src="./js-aruco/posit1-patched.js"></script>
	<script type="text/javascript" src="./js-aruco/svd.js"></script>
	<script type="text/javascript" src="./three/three.min.js"></script>
	<script type="text/javascript" src="./three/STLLoader.js"></script>
    <script type="text/javascript" src="./libs/stats.js"></script>
    <script type="text/javascript" src="./libs/dat.gui.js"></script>
	<script type="text/javascript" src="./jsfeat/jsfeat-min.js"></script>
	<script type="text/javascript" src="./js/track.js"></script>
	<script type="text/javascript" src="./js/threed.js"></script>
	<script type="text/javascript" src="./js/aiming.js"></script>
	<script type="text/javascript" src="./js/pattern.js"></script>
<!--    <script type="text/javascript" src="./libs/jquery-1.11.2.min.js"></script> -->
<style>
	.div-relative{position:relative; color:#000; border:1px solid #000; width:100%; height:100%}    
	.div-screen{ position:relative; left:0px; top:0px; padding-bottom:75%;  background-color:transparent; width:100%; height:100%}
	.div-screen video{ position:absolute; left:0px; top:0px; width:100%; height:100%}
	.div-canvas{ position:absolute; left:0px; top:0px; background-color:transparent; width:100%; height:100%} 
	body{margin: 0; overflow: hidden;}
</style>
</head>
<body>
	<div class="div-screen">
		<!--<video id="webcam" autoplay style="width:100%; height: 100%; object-fit: fill">您的浏览器不支持video标签。 </video> -->
		<video id="webcam" autoplay style="width:100%; height: 100%;">您的浏览器不支持video标签。 </video>
	</div>
	<div class="div-canvas">
		<canvas id="bufcan" style="display:none"></canvas>
	</div>
	<div class="div-canvas">
		<canvas id="arcan" style="display:none"></canvas>
	</div>
	<div id="3D-canvas" class="div-canvas">
	</div>
	<!--<div style="overflow: hidden;width:0px;height:0px;">
		<img id="captureimg" src="./imgs/rp4.gif"></img>
	</div> -->

	<script type="text/javascript">
		var width = window.innerWidth;
		//var height = window.innerHeight;
		var height = width / 3 * 4;
		var size = width * height;
		console.log("size:" + width + "*" + height);
		var webcam = document.getElementById('webcam');
		webcam.style.width = width + "px";
		webcam.style.height = height + "px";

		var bufcan = document.getElementById('bufcan');
		bufcan.width = width;
		bufcan.height = height;
		//var bufctx = bufcan.getContext('2d');

		var gl = bufcan.getContext('webgl'); //experimental-webgl
		var tex = gl.createTexture();
  		gl.bindTexture(gl.TEXTURE_2D, tex);
  		gl.bindFramebuffer(gl.FRAMEBUFFER, gl.createFramebuffer());
  		gl.viewport(0, 0, width, height);
 		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
 		var imageData = new Uint8Array(width * height * 4);

		var arcan = document.getElementById('arcan');
		var arctx = arcan.getContext('2d');
		arcan.width = width;
		arcan.height = height;
		arctx.fillStyle = "green";
		arctx.strokeStyle = "rgb(0,255,0)";
        //arctx.lineWidth = 1;
		//alert(width + ":" + height);

		//var captureimg = document.getElementById('captureimg');
		//captureimg.play();
		//isCaptured = true;
		document.addEventListener('touchend', captureFairy, false);

		//	initModel(width, height);
		initAiming(width, height, arctx);
		initPattern();
		
		function hasGetUserMedia() {
			return  !!(navigator.getUserMedia
				|| navigator.webkitGetUserMedia || navigator.mozGetUserMedia
				|| navigator.msGetUserMedia);
		}
		
		window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
		var videoDevices = []; //存储设备源ID
		//MediaStreamTrack.getSources(function(sourceInfos) {
		navigator.mediaDevices.enumerateDevices().then(function(devices) {
			for (var i = 0; i < devices.length; i++) {
				var device = devices[i];
				if ((device.kind === 'videoinput') && (device.label.indexOf('back') >= 0)) {
					videoDevices.push(device.deviceId);
				//	videoLabels.push(device.label);
				}
			}
			openWebCam();
			arcan.style.display = 'block';
		});
		
		function openWebCam() {
			if (navigator.getUserMedia) { // 标准的API
				navigator.getUserMedia({
					video : {
						deviceId : { exact: videoDevices[0]  },
						width : { min: width, ideal : width, max: width },
						height : { min: height, ideal : height, max: height },
						/*'optional' : [ {
							'deviceId' : exArray[1] //0为前置摄像头，1为后置  
						} ]*/
					},
					audio : false
				}, successFunc, errorFunc);
			} else if (navigator.webkitGetUserMedia) { // WebKit 核心的API
				navigator.webkitGetUserMedia({
					video : {
						deviceId : { exact: videoDevices[0] },
						width : { min: width, ideal : width, max: width },
						height : { min: height, ideal : height, max: height },
					},
					audio : false
				}, successFunc, errorFunc);
			} else {
				alert('Native device media streaming (getUserMedia) not supported in your browser.');
			}
		}

		var localStream, grayImg, blurImg;
		var corners = [];
		var matches = [];
		var homo3x3, match_mask;
		// our point match structure
        var match_t = (function () {
            function match_t(screen_idx, pattern_lev, pattern_idx, distance) {
                if (typeof screen_idx === "undefined") { screen_idx=0; }
                if (typeof pattern_lev === "undefined") { pattern_lev=0; }
                if (typeof pattern_idx === "undefined") { pattern_idx=0; }
                if (typeof distance === "undefined") { distance=0; }

                this.screen_idx = screen_idx;
                this.pattern_lev = pattern_lev;
                this.pattern_idx = pattern_idx;
                this.distance = distance;
            }
            return match_t;
        })();

		function successFunc(stream) {
			webcam.src = window.URL && window.URL.createObjectURL(stream) || stream;
			//var inputTrack = stream.getVideoTracks()[0];
			//video.src = URL.createObjectURL(stream);
			//video.src = stream;
			webcam.play();
			localStream = stream;

			grayImg = new jsfeat.matrix_t(width, height, jsfeat.U8_t | jsfeat.C1_t);
			//blurImg = new jsfeat.matrix_t(width, height, jsfeat.U8_t | jsfeat.C1_t);
			// you should use preallocated keypoint_t array
			for (var i = 0; i < size; i++) {
			    corners[i] = new jsfeat.keypoint_t(0, 0, 0, 0);
			    matches[i] = new match_t();
			}
			homo3x3 = new jsfeat.matrix_t(3, 3, jsfeat.F32C1_t);
			match_mask = new jsfeat.matrix_t(500, 1, jsfeat.U8C1_t);
			requestAnimationFrame(imageProcessing);
		}

		function errorFunc(error) {
			console.log("Error:" + error.name);
		}

		function closeWebCam() {
			if (webcam) {
				webcam.pause();
				webcam.src = '';
			//	webcam.load();
			}
			if (localStream && localStream.stop) {
				localStream.stop();
			}
			stream = null;
		}
		
		
		var lastTime, ptnDescs, scnDescs;
		var isTracking = false;
		//var imageData;
		function getImageData() {
		//	arctx.drawImage(webcam, 0, 0);
		//	imageData = arctx.getImageData(0, 0, width, height).data;
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, webcam);
			gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
		}

		function imageProcessing() {
			lastTime = Date.now();
			requestAnimationFrame(imageProcessing);
			if (isCaptured) {
				drawCapture(arctx);
				return;
			}
			if (isPatternReady && webcam.readyState === webcam.HAVE_ENOUGH_DATA) {
				getImageData();
				arctx.clearRect(0, 0, width, height);
				//drawStatus(0, tps);
				//return;
				
				//jsfeat.imgproc.gaussian_blur(grayImg, blurImg, 5);
				//drawGrayImage(imageData, grayImg);

				if (isTracking) {
					var tps = tracking(imageData, arctx);
					if (tps >= 8) {
						//jsfeat.matmath.multiply_3x3(homo3x3, homo3x3, track3x3);
						if (drawShape(track3x3)) {
							drawAiming(arctx, track3x3, false);
							drawStatus(0, tps);
							return;
						} else {
							isTracking = false;
						}
					} else {
						isTracking = false;
					}
				}

				jsfeat.imgproc.grayscale(imageData, width, height, grayImg);
				var count = detectKeypoints(grayImg, corners, 120);
				//console.log("keypoint size:" + count);
			//	drawKeypoints(corners, count);

			//	var cols = 32; // 32 Bytes / 256 BIT descriptor
			//	var rows = count; // descriptors stored per row
				scnDescs = new jsfeat.matrix_t(32, count, jsfeat.U8_t | jsfeat.C1_t);
				jsfeat.orb.describe(grayImg, corners, count, scnDescs);
				var candMatches = matchPattern(ptnDescs, scnDescs);
				var goodMatches = findTransform(matches, candMatches);
			//	console.log("candidate matches:" + candMatches  + "\tgood matches:" + goodMatches);
				if (goodMatches >= 8)  {
					resetPatternShape();
					if (drawShape(homo3x3)) {
						initTrack(imageData, corners, width, height);
						isTracking = true;
						drawAiming(arctx, homo3x3, true);
						//canvas3d.style.display = "block";
					}
				}

				drawStatus(goodMatches, 0);
			}
			
		//	snapshot();
		}

		function drawStatus(mks, tps) {
			//drawModel(ptnShape);
			
			var fps = 1000.0 / (Date.now()- lastTime);
			var tmp = "FPS:" + fps;
			arctx.fillText(tmp.substr(0, tmp.indexOf(".") + 2) + "  MKS:" + mks + " TPS:" + tps, 20, 20);
		}

		function drawGrayImage(imageData, grayImg) {
			var data_u32 = new Uint32Array(imageData.buffer);
            var i = size; //grayImg.cols * grayImg.rows;
            var pix = 0;
            var alpha = (0xff << 24);
            while(--i >= 0) {
            	pix = grayImg.data[i];
            	data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
            }
            arctx.putImageData(imageData, 0, 0); //???imageData.data
		}

		function detectKeypoints(image, corners, maxAllowed) {//var threshold = 10;
			//var border = 3;
			jsfeat.fast_corners.set_threshold(10);
			var count = jsfeat.fast_corners.detect(image, corners, 3);
			//var count = jsfeat.yape06.detect(image, corners, 17);

            // sort by score and reduce the count if needed
            if(count > maxAllowed) {
            	jsfeat.math.qsort(corners, 0, count - 1, function(a, b){return (b.score < a.score);});
            	count = maxAllowed;
            }
            /*
            // calculate dominant orientation for each keypoint
           	for(var i = 0; i < count; ++i) {
                corners[i].angle = ic_angle(img, corners[i].x, corners[i].y);
            }
			*/
            return count;
        }

        function drawKeypoints(corners, count) {
        	for (var i = 0; i < count; i++) {
			    arctx.fillRect(corners[i].x, corners[i].y, 4, 4);
			}
        }
		
		// non zero bits count
		function popcnt32(n) {
			n -= ((n >> 1) & 0x55555555);
			n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
			return (((n + (n >> 4))& 0xF0F0F0F)* 0x1010101) >> 24;
        }

        // naive brute-force matching. each on screen point is 
        // compared to all pattern points to find the closest match
       	function matchPattern(ptnDescs, scnDescs) {
       		//console.log("SCENE:" + scnDescs.rows + "PATTERN:" + ptnDescs.rows);
       		var q_cnt = scnDescs.rows;
       		var query_du8 = scnDescs.data;
       		var query_u32 = scnDescs.buffer.i32; // cast to integer buffer
       		var qd_off = 0;
       		var qidx=0,lev=0,pidx=0,k=0;
       		var num_matches = 0;

            for (qidx = 0; qidx < q_cnt; qidx++) {
            	var best_dist = 256;
            	var best_dist2 = 256;
            	var best_idx = -1;
            //    var best_lev = -1;

        //        for(lev = 0; lev < num_train_levels; lev++) {
        //        	var lev_descr = ptnDescs[i];
                	var ld_cnt = ptnDescs.rows;
                	var ld_i32 = ptnDescs.buffer.i32; // cast to integer buffer
                	var ld_off = 0;

                    for(pidx = 0; pidx < ld_cnt; pidx++) {
                    	var curr_d = 0;
                        // our descriptor is 32 bytes so we have 8 Integers
                        for(k=0; k < 8; ++k) {
                        	curr_d += popcnt32( query_u32[qd_off+k]^ld_i32[ld_off+k] );
                        }

                        if(curr_d < best_dist) {
                        	best_dist2 = best_dist;
                        	best_dist = curr_d;
                    //    	best_lev = lev; 
                        	best_idx = pidx;
                        } else if(curr_d < best_dist2) {
                            best_dist2 = curr_d;
                        }

                        ld_off += 8; // next descriptor
                    }
            //    }

                // filter out by some threshold\
               // var match_threshold = 48;
                /*if(best_dist < 48) {
                    matches[num_matches].screen_idx = qidx;
                //    matches[num_matches].pattern_lev = best_lev;
                    matches[num_matches].pattern_idx = best_idx;
                    num_matches++;
                }*/
                // filter using the ratio between 2 closest matches
                if(best_dist < 0.6*best_dist2) {
                    matches[num_matches].screen_idx = qidx;
                //    matches[num_matches].pattern_lev = best_lev;
                    matches[num_matches].pattern_idx = best_idx;
                    num_matches++;
                }

                qd_off += 8; // next query descriptor
            }
            return num_matches;
        }

    	// estimate homography transform between matched points
    	var mm_kernel = new jsfeat.motion_model.homography2d();
        function findTransform(matches, count) {
            // ransac params
            //var num_model_points = 4;
            //var reproj_threshold = 3;
            var ransac_param = new jsfeat.ransac_params_t(4, 3, 0.5, 0.99);

            var pattern_xy = [];
            var screen_xy = [];

            // construct correspondences
            for(var i = 0; i < count; ++i) {
                var m = matches[i];
                var s_kp = corners[m.screen_idx];
                var p_kp = ptnCorners[m.pattern_idx];
                pattern_xy[i] = {"x":p_kp.x, "y":p_kp.y};
                screen_xy[i] =  {"x":s_kp.x, "y":s_kp.y};
            }

            // estimate motion
            var ok = false;
            ok = jsfeat.motion_estimator.ransac(ransac_param, mm_kernel,
                	pattern_xy, screen_xy, count, homo3x3, match_mask, 1000);

            // extract good matches and re-estimate
            var good_cnt = 0;
            if(ok) {
            	for(var i=0; i < count; ++i) {
                    if(match_mask.data[i]) {
                        pattern_xy[good_cnt].x = pattern_xy[i].x;
                        pattern_xy[good_cnt].y = pattern_xy[i].y;
                        screen_xy[good_cnt].x = screen_xy[i].x;
                        screen_xy[good_cnt].y = screen_xy[i].y;
                        good_cnt++;
                    }
                }

                // run kernel directly with inliers only
                mm_kernel.run(pattern_xy, screen_xy, homo3x3, good_cnt);
            } else {
                jsfeat.matmath.identity_3x3(homo3x3, 1.0);
            }

            return good_cnt;
        }

        function drawShape(matrix3x3) {
            // get the projected pattern corners
            //var shape_pts = tCorners(homo3x3.data, ptnWidth, ptnHeight);
            /*
            var M = matrix3x3.data;
            var z=0.0, px=0.0, py=0.0;
            for (var i = 0; i < 4; i++) {
            	px = M[0]*ptnShape[i].x + M[1]*ptnShape[i].y + M[2];
            	py = M[3]*ptnShape[i].x + M[4]*ptnShape[i].y + M[5];
            	z = M[6]*ptnShape[i].x + M[7]*ptnShape[i].y + M[8];
            	ptnShape[i].x = px/z;
            	ptnShape[i].y = py/z;
            }*/
            transformCorners(matrix3x3.data, ptnShape);

            if (!isValidMatch(ptnShape))
            	return false;

            arctx.beginPath();
            arctx.moveTo(ptnShape[0].x, ptnShape[0].y);
            arctx.lineTo(ptnShape[1].x, ptnShape[1].y);
            arctx.lineTo(ptnShape[2].x, ptnShape[2].y);
            arctx.lineTo(ptnShape[3].x, ptnShape[3].y);
            arctx.lineTo(ptnShape[0].x, ptnShape[0].y);
            arctx.stroke();
            return true;
        }

        function direction(pi, pj, pk) {
			return (pi.x - pk.x) * (pi.y - pj.y) - (pi.y - pk.y) * (pi.x - pj.x);
		}

		function isValidMatch(corners) {
			var d1 = direction(corners[1], corners[3], corners[0]);
			var d2 = direction(corners[1], corners[3], corners[2]);
			var d3 = direction(corners[0], corners[2], corners[1]);
			var d4 = direction(corners[0], corners[2], corners[3]);
			if ((d1 * d2 < 0) && (d3 * d4 < 0))
				return true;
			else 
				return false;
		}

        // project/transform rectangle corners with 3x3 Matrix
        function transformCorners(M, corners) {
            //var pt = [ {'x':0,'y':0}, {'x':w,'y':0}, {'x':w,'y':h}, {'x':0,'y':h} ];
            var z=0.0, px=0.0, py=0.0;
            for (var i = 0; i < 4; i++) {
            	px = M[0]*corners[i].x + M[1]*corners[i].y + M[2];
            	py = M[3]*corners[i].x + M[4]*corners[i].y + M[5];
            	z = M[6]*corners[i].x + M[7]*corners[i].y + M[8];
            	corners[i].x = px / z;
            	corners[i].y = py / z;
            }
            return;
        }

	//	$(function() { 
	//		alert("xxx");
	//	});
	//	window.onload = initPattern();
		window.unload = closeWebCam();
	</script>
</body>
</html>